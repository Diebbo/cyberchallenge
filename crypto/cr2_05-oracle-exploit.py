from Crypto.Util.number import long_to_bytes, inverse
from pwn import *
import math

HOST = "oracle.challs.cyberchallenge.it"
PORT = 9041

r = remote(HOST, PORT)

flag_encrypted = 64869382728980811819664887232826417910434456617753678571946421713277668808051720293635879114689970771821313869830659813845120028283648083977158540836225652121997684783064741987396285700743565962135783536872060641998025897004409244260719316835787757179626362229564095045555567062692937996489671319097516149204

def get_n():
    # Choose two values
    a = 2
    b = 3
    
    # Encrypt a
    r.sendlineafter(b"> ", b"1")
    r.sendlineafter(b"Plaintext > ", str(a).encode())
    a_enc = int(r.recvline_startswith(b"Encrypted: ").strip().split(b": ")[1])
    print(f"Encrypted {a} = {a_enc}")
    
    # Encrypt b
    r.sendlineafter(b"> ", b"1")
    r.sendlineafter(b"Plaintext > ", str(b).encode())
    b_enc = int(r.recvline_startswith(b"Encrypted: ").strip().split(b": ")[1])
    print(f"Encrypted {b} = {b_enc}")
    
    # Get a*b encrypted
    r.sendlineafter(b"> ", b"1")
    r.sendlineafter(b"Plaintext > ", str(a*b).encode())
    ab_enc = int(r.recvline_startswith(b"Encrypted: ").strip().split(b": ")[1])
    print(f"Encrypted {a*b} = {ab_enc}")
    
    # Calculate n using the homomorphic property
    # If a_enc = a^e mod n, b_enc = b^e mod n, ab_enc = (a*b)^e mod n
    # Then (a_enc * b_enc) mod n = a^e * b^e mod n = (a*b)^e mod n = ab_enc mod n
    # So ab_enc - (a_enc * b_enc) must be a multiple of n
    n = math.gcd(ab_enc - (a_enc * b_enc), a_enc * b_enc)
    print(f"Found n = {n}")
    return n

def get_flag(n):
    # Choose a random value for blinding
    s = 2
    
    # Calculate s^e mod n by encrypting s
    r.sendlineafter(b"> ", b"1")
    r.sendlineafter(b"Plaintext > ", str(s).encode())
    s_enc = int(r.recvline_startswith(b"Encrypted: ").strip().split(b": ")[1])
    
    # Blind the ciphertext: (c * s^e) mod n
    blinded = (flag_encrypted * s_enc) % n
    
    # Ask oracle to decrypt the blinded ciphertext
    r.sendlineafter(b"> ", b"2")
    r.sendlineafter(b"Ciphertext > ", str(blinded).encode())
    blinded_decrypted = int(r.recvline_startswith(b"Decrypted: ").strip().split(b": ")[1])
    
    # Unblind the decrypted value: (blinded_decrypted / s) mod n
    s_inv = inverse(s, n)
    flag = (blinded_decrypted * s_inv) % n
    
    return long_to_bytes(flag)

try:
    # Get the modulus
    n = get_n()
    
    # Get the flag
    flag = get_flag(n)
    print(f"Flag: {flag.decode()}")
except Exception as e:
    print(f"Error: {e}")
finally:
    r.close()

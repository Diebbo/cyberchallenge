from Crypto.Util.number import long_to_bytes, inverse
from pwn import *
import math

HOST = "oracle.challs.cyberchallenge.it"
PORT = 9041

r = remote(HOST, PORT)

eflag = int(r.recvline_startswith(b"Encrypted flag: ").strip().split(b": ")[1])

def solve():
    # Choose two small values
    a = 2
    b = 3

    # Encrypt a
    r.sendlineafter(b"> ", b"1")
    r.sendlineafter(b"Plaintext > ", str(a).encode())
    a_enc = int(r.recvline_startswith(b"Encrypted: ").strip().split(b": ")[1])
    print(f"Encrypted {a} = {a_enc}")

    # Encrypt b
    r.sendlineafter(b"> ", b"1")
    r.sendlineafter(b"Plaintext > ", str(b).encode())
    b_enc = int(r.recvline_startswith(b"Encrypted: ").strip().split(b": ")[1])
    print(f"Encrypted {b} = {b_enc}")

    # Compute n
    e = 65537
    n = math.gcd(a**e - a_enc, b**e - b_enc)
    print(f"Found n (candidate) = {n}")

    # Verify n with another value if needed
    # (Optional: encrypt another value and check)

    # If the oracle allows decryption, perform a blinding attack
    # Choose random r
    r_val = 2  # small random value
    r.sendlineafter(b"> ", b"1")
    r.sendlineafter(b"Plaintext > ", str(r_val).encode())
    r_enc = int(r.recvline_startswith(b"Encrypted: ").strip().split(b": ")[1])

    # Compute eflag * r_enc mod n
    blinded = (eflag * r_enc) % n

    # Ask the oracle to decrypt the blinded ciphertext
    r.sendlineafter(b"> ", b"2")  # assuming 2 is the decrypt option
    r.sendlineafter(b"Ciphertext > ", str(blinded).encode())
    blinded_dec = int(r.recvline_startswith(b"Decrypted: ").strip().split(b": ")[1])

    # Recover the flag: flag = (blinded_dec * r^-1) mod n
    flag = (blinded_dec * inverse(r_val, n)) % n
    print(f"Decrypted flag: {long_to_bytes(flag)}")

try:
    # Get the modulus
    solve()
except Exception as e:
    print(f"Error: {e}")
finally:
    r.close()
